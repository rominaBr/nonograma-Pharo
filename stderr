[31mInstance of VentanaInicio did not understand #dibujarInstrucciones
[0mVentanaInicio(Object)>>doesNotUnderstand: #dibujarInstrucciones
VentanaInicio(VentanaBase)>>redibujarVentanaCon:
VentanaInicio>>accionInstrucciones
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[0m[31mInstance of VentanaInicio did not understand #informacionInicio
[0mVentanaInicio(Object)>>doesNotUnderstand: #informacionInicio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of VentanaInicio did not understand #informacionInicio
[0mVentanaInicio(Object)>>doesNotUnderstand: #informacionInicio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0mpatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
CeldaMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
[0m[31mInstance of Partida did not understand #estadoJugadores
[0mPartida(Object)>>doesNotUnderstand: #estadoJugadores
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:conJuego:
Juego>>iniciarPartida2P:contra:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
[0mMorphFront:
Morph>>addMorph:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
[0m[31mInstance of CeldaMorph did not understand #propertyAt:
[0mCeldaMorph(Object)>>doesNotUnderstand: #propertyAt:
CeldaMorph>>mouseDown:
CeldaMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
CeldaMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
CeldaMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
[0mocessEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mInstance of True did not understand #ifF:
[0mTrue(Object)>>doesNotUnderstand: #ifF:
CeldaMorph>>mouseDown:
CeldaMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
CeldaMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
CeldaMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
[0m ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Partida did not understand #jugadores
[0mPartida(Object)>>doesNotUnderstand: #jugadores
VentanaJuego>>accionVerificar
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Partida did not understand #jugadores
[0mPartida(Object)>>doesNotUnderstand: #jugadores
VentanaJuego>>accionVerificar
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0mphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 92
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 92
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 90
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 87
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 87
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 201
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionDificil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 210
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionDificil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mInstance of Tablero did not understand #dimension
[0mTablero(Object)>>doesNotUnderstand: #dimension
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[0m[31mPrimitiveFailed: primitive #basicNew: in Array class failed
[0mArray class(ProtoObject)>>primitiveFailed:
Array class(ProtoObject)>>primitiveFailed
Array class(Behavior)>>basicNew:
Array class>>new:
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
[0m[31mPrimitiveFailed: primitive #basicNew: in Array class failed
[0mArray class(ProtoObject)>>primitiveFailed:
Array class(ProtoObject)>>primitiveFailed
Array class(Behavior)>>basicNew:
Array class>>new:
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
[0m[31mPrimitiveFailed: primitive #basicNew: in Array class failed
[0mArray class(ProtoObject)>>primitiveFailed:
Array class(ProtoObject)>>primitiveFailed
Array class(Behavior)>>basicNew:
Array class>>new:
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
[0m[31m#adaptToNumber:andSend: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
[0m[31m#adaptToNumber:andSend: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31m#adaptToNumber:andSend: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
[0m[31m#adaptToNumber:andSend: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
[0m[31mInstance of VentanaJuego did not understand #dibujarPistasFilas:
[0mVentanaJuego(Object)>>doesNotUnderstand: #dibujarPistasFilas:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
[0m[31mInstance of VentanaJuego did not understand #construirLabelConTexto:
[0mVentanaJuego(Object)>>doesNotUnderstand: #construirLabelConTexto:
VentanaJuego>>dibujarPistasFilas:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mInstance of Ventana class did not understand #construirLabelConTexto:
[0mVentana class(Object)>>doesNotUnderstand: #construirLabelConTexto:
VentanaJuego>>dibujarPistasFilas:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mInstance of VentanaJuego did not understand #construirBotonVerificar
[0mVentanaJuego(Object)>>doesNotUnderstand: #construirBotonVerificar
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
[0m[31mInstance of Ventana did not understand #accionVerificar
[0mVentana(Object)>>doesNotUnderstand: #accionVerificar
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Ventana did not understand #accionVerificar
[0mVentana(Object)>>doesNotUnderstand: #accionVerificar
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of VentanaJuego did not understand #dibujarPistasColumnas:tamaÃ±o:
[0mVentanaJuego(Object)>>doesNotUnderstand: #dibujarPistasColumnas:tamaÃ±o:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
[0m[31mInstance of VentanaJuego did not understand #construirLabelConTexto:
[0mVentanaJuego(Object)>>doesNotUnderstand: #construirLabelConTexto:
VentanaJuego>>dibujarPistasFilas:tamaÃ±o:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m