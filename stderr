[31mDuplicatedSlotName: Slot #'juego' appeared twice in VentanaInicio
[0m[ :other | 
other name = current name
	ifTrue: [ DuplicatedSlotName new
			oldSlot: current;
			newSlot: other;
			host: host;
			signal ] ] in FixedLayout(PointerLayout)>>checkSlotNames in Block: [ :other | ...
OrderedCollection>>do:
FixedLayout(PointerLayout)>>checkSlotNames
FixedLayout(PointerLayout)>>checkSanity
VentanaInicio class(ClassDescription)>>superclass:withLayoutType:slots:
ShDefaultBuilderEnhancer>>configureClass:superclass:withLayoutType:slots:
ShiftClassBuilder>>createClass
ShiftClassBuilder>>build
[ builder oldClass: oldClass.
self copyClassSlotsFromExistingClass.
newClass := builder build.
self installInEnvironment: newClass.
self installSubclassInSuperclass: newClass.
builder builderEnhancer beforeMigratingClass: builder installer: self.
builder builderEnhancer migrateToClass: newClass installer: self.
builder builderEnhancer afterMigratingClass: builder installer: self.
builder builderEnhancer
	propagateChangesToRelatedClasses: newClass
	installer: self ] in ShiftClassInstaller>>make in Block: [ builder oldClass: oldClass....
BlockClosure>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
VentanaBase class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
VentanaBase class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowser>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChanges
[ self changesAreAboutApply.
applied := self applyChanges ] in [ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ self changesAreAboutApply....
BlockClosure>>on:do:
[ textMorph hasUnacceptedEdits: true.
[ self changesAreAboutApply.
applied := self applyChanges ]
	on: Error
	do: [ :err | 
		textModel text: self editingText.
		textMorph hasUnacceptedEdits: true.
		err pass ].
applied
	ifTrue: [ textMorph hasUnacceptedEdits: false.
		self textUpdated.
		browser focusActiveTab ]
	ifFalse: [ textModel text: self editingText.
		textMorph hasUnacceptedEdits: true ] ] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ textMorph hasUnacceptedEdits: true....
BlockClosure>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
[0muego in Block: [ self actualizarInfoPara: estado1 vidas: vLabel1 ...etc...
CeldaMorph>>finalizarJugada:
CeldaMorph>>manejarClickIzquierdo
CeldaMorph>>mouseDown:
CeldaMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
CeldaMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
CeldaMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
[0m[31mInstance of Partida did not understand #estadoJugadores
[0mPartida(Object)>>doesNotUnderstand: #estadoJugadores
CeldaMorph>>finalizarJugada:
CeldaMorph>>manejarClickDerecho
CeldaMorph>>mouseDown:
CeldaMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
CeldaMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
CeldaMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
[0m[31mInstance of Partida did not understand #estadoJugadores
[0mPartida(Object)>>doesNotUnderstand: #estadoJugadores
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:conJuego:
Juego>>iniciarPartida2P:contra:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
[0mMorphFront:
Morph>>addMorph:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
[0m[31mInstance of CeldaMorph did not understand #propertyAt:
[0mCeldaMorph(Object)>>doesNotUnderstand: #propertyAt:
CeldaMorph>>mouseDown:
CeldaMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
CeldaMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
CeldaMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
[0mocessEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mInstance of True did not understand #ifF:
[0mTrue(Object)>>doesNotUnderstand: #ifF:
CeldaMorph>>mouseDown:
CeldaMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
CeldaMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
CeldaMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
[0m ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Partida did not understand #jugadores
[0mPartida(Object)>>doesNotUnderstand: #jugadores
VentanaJuego>>accionVerificar
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Partida did not understand #jugadores
[0mPartida(Object)>>doesNotUnderstand: #jugadores
VentanaJuego>>accionVerificar
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0mphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 92
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 92
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 90
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 87
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 87
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 201
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionDificil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mSubscriptOutOfBounds: 210
[0mByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
Tablero class>>convertirString:aMatrizDe:
Tablero class>>cargarTableroDesde:dificultad:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionDificil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mInstance of Tablero did not understand #dimension
[0mTablero(Object)>>doesNotUnderstand: #dimension
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[0m[31mPrimitiveFailed: primitive #basicNew: in Array class failed
[0mArray class(ProtoObject)>>primitiveFailed:
Array class(ProtoObject)>>primitiveFailed
Array class(Behavior)>>basicNew:
Array class>>new:
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
[0m[31mPrimitiveFailed: primitive #basicNew: in Array class failed
[0mArray class(ProtoObject)>>primitiveFailed:
Array class(ProtoObject)>>primitiveFailed
Array class(Behavior)>>basicNew:
Array class>>new:
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionMedio
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
[0m[31mPrimitiveFailed: primitive #basicNew: in Array class failed
[0mArray class(ProtoObject)>>primitiveFailed:
Array class(ProtoObject)>>primitiveFailed
Array class(Behavior)>>basicNew:
Array class>>new:
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
[0m[31m#adaptToNumber:andSend: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
[0m[31m#adaptToNumber:andSend: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[0m[31m#adaptToNumber:andSend: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
[0m[31m#adaptToNumber:andSend: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
Message>>sentTo:
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grilla>>initializeDeDimension:
Partida>>addJugador:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
[0m[31mInstance of VentanaJuego did not understand #dibujarPistasFilas:
[0mVentanaJuego(Object)>>doesNotUnderstand: #dibujarPistasFilas:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
[0m[31mInstance of VentanaJuego did not understand #construirLabelConTexto:
[0mVentanaJuego(Object)>>doesNotUnderstand: #construirLabelConTexto:
VentanaJuego>>dibujarPistasFilas:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mInstance of Ventana class did not understand #construirLabelConTexto:
[0mVentana class(Object)>>doesNotUnderstand: #construirLabelConTexto:
VentanaJuego>>dibujarPistasFilas:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m[31mInstance of VentanaJuego did not understand #construirBotonVerificar
[0mVentanaJuego(Object)>>doesNotUnderstand: #construirBotonVerificar
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
[0m[31mInstance of Ventana did not understand #accionVerificar
[0mVentana(Object)>>doesNotUnderstand: #accionVerificar
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of Ventana did not understand #accionVerificar
[0mVentana(Object)>>doesNotUnderstand: #accionVerificar
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of VentanaJuego did not understand #dibujarPistasColumnas:tamaÃ±o:
[0mVentanaJuego(Object)>>doesNotUnderstand: #dibujarPistasColumnas:tamaÃ±o:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
[0m[31mInstance of VentanaJuego did not understand #construirLabelConTexto:
[0mVentanaJuego(Object)>>doesNotUnderstand: #construirLabelConTexto:
VentanaJuego>>dibujarPistasFilas:tamaÃ±o:
VentanaJuego>>dibujarJuego
VentanaJuego>>open
VentanaJuego class>>openOn:
Juego>>iniciarPartida1P:dificultad:
Ventana>>accionFacil
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from: in Block: [ :s | result := result | ((s notify: anEvent from...etc...
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseUp:fromMorph:
ImageMorph(Morph)>>mouseUp:
ImageMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ImageMorph(Morph)>>handleEvent:
ImageMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear: in Block: [ ActiveHand := self....
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
[0m